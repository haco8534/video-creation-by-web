/**
 * generate-subtitle-data.js
 *
 * main content の scene_map.json + scene_durations.json を読み込んで、
 * Remotion で使用する字幕タイミングデータ (TypeScript) を生成する。
 *
 * 使い方:
 *   node scripts/generate-subtitle-data.js <main_content_dir> <project_id>
 *
 * 例:
 *   node scripts/generate-subtitle-data.js "d:/myfolder/動画生成/main content/presentation/10000h_effort" 10000h_effort
 *
 * 出力:
 *   src/projects/<project_id>/subtitleData.ts
 */

const fs = require('fs');
const path = require('path');

const mainContentDir = process.argv[2];
const projectId = process.argv[3];

if (!mainContentDir || !projectId) {
    console.error('Usage: node generate-subtitle-data.js <main_content_dir> <project_id>');
    process.exit(1);
}

const sceneMapPath = path.join(mainContentDir, 'scene_map.json');
const sceneDurationsPath = path.join(mainContentDir, 'scene_durations.json');

const sceneMap = JSON.parse(fs.readFileSync(sceneMapPath, 'utf-8'));
const sceneDurations = JSON.parse(fs.readFileSync(sceneDurationsPath, 'utf-8'));

const FPS = 30;
const interLineSilence = sceneMap.inter_line_silence || 0.3;
const sceneEndPadding = sceneMap.scene_end_padding || 0.5;

// ローマ字speaker名 → 日本語表示名の変換マップ
const SPEAKER_DISPLAY_NAMES = {
    'zundamon': 'ずんだもん',
    'metan': 'めたん',
    // 日本語の場合はそのまま
    'ずんだもん': 'ずんだもん',
    'めたん': 'めたん',
};

// キャラクターカラー（日本語名とローマ字名の両方をカバー）
const SPEAKER_COLORS = {
    'ずんだもん': '#22c55e',
    'めたん': '#d6336c',
    'zundamon': '#22c55e',
    'metan': '#d6336c',
};

/**
 * 各セリフの絶対開始時間(秒)・開始フレーム・話者・テキストをフラットに計算する
 */
const subtitleEntries = [];
let absoluteTimeSec = 0;

for (const sceneDur of sceneDurations) {
    const sceneMapEntry = sceneMap.scenes.find(s => s.id === sceneDur.id);
    if (!sceneMapEntry) {
        // scene_map にない場合はそのシーンの duration を飛ばす
        absoluteTimeSec += sceneDur.duration;
        continue;
    }

    if (sceneMapEntry.lines.length === 0) {
        // セリフなしシーン (タイトルなど)
        absoluteTimeSec += sceneDur.duration;
        continue;
    }

    // audioFiles から各セリフの duration を取得
    const audioFiles = sceneDur.audioFiles || [];
    let lineTime = absoluteTimeSec;

    for (let i = 0; i < sceneMapEntry.lines.length; i++) {
        const line = sceneMapEntry.lines[i];
        const audioInfo = audioFiles[i];
        const lineDuration = audioInfo ? audioInfo.duration : 2; // fallback
        const displaySpeaker = SPEAKER_DISPLAY_NAMES[line.speaker] || line.speaker;

        subtitleEntries.push({
            startTimeSec: lineTime,
            startFrame: Math.round(lineTime * FPS),
            durationSec: lineDuration,
            durationFrames: Math.round(lineDuration * FPS),
            speaker: displaySpeaker,
            text: line.text,
            speakerColor: SPEAKER_COLORS[line.speaker] || '#888888',
            sceneId: sceneDur.id,
            sceneTitle: sceneDur.title,
        });

        lineTime += lineDuration + interLineSilence;
    }

    absoluteTimeSec += sceneDur.duration;
}

// 動画の総時間（秒）
const totalDurationSec = sceneDurations.reduce((sum, s) => sum + s.duration, 0);
const totalFrames = Math.round(totalDurationSec * FPS);

// TypeScript ファイルとして出力
const outputDir = path.join(__dirname, '..', 'src', 'projects', projectId);
if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
}

const outputPath = path.join(outputDir, 'subtitleData.ts');

const tsContent = `// Auto-generated by generate-subtitle-data.js
// Source: ${path.basename(mainContentDir)}
// Generated at: ${new Date().toISOString()}

export interface SubtitleEntry {
    startTimeSec: number;
    startFrame: number;
    durationSec: number;
    durationFrames: number;
    speaker: string;
    text: string;
    speakerColor: string;
    sceneId: number;
    sceneTitle: string;
}

export const FPS = ${FPS};
export const TOTAL_DURATION_SEC = ${totalDurationSec};
export const TOTAL_FRAMES = ${totalFrames};

export const SUBTITLE_DATA: SubtitleEntry[] = ${JSON.stringify(subtitleEntries, null, 2)};
`;

fs.writeFileSync(outputPath, tsContent, 'utf-8');

console.log(`✅ Generated: ${outputPath}`);
console.log(`   Total subtitle entries: ${subtitleEntries.length}`);
console.log(`   Total duration: ${totalDurationSec.toFixed(1)}s (${totalFrames} frames)`);
console.log(`   First entry: [${subtitleEntries[0]?.startFrame}f] ${subtitleEntries[0]?.speaker}: ${subtitleEntries[0]?.text.slice(0, 30)}...`);
console.log(`   Last entry:  [${subtitleEntries[subtitleEntries.length - 1]?.startFrame}f] ${subtitleEntries[subtitleEntries.length - 1]?.speaker}: ${subtitleEntries[subtitleEntries.length - 1]?.text.slice(0, 30)}...`);
