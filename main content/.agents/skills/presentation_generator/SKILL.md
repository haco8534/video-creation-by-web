---
name: presentation_generator
description: 台本から高品質なWebアニメーション・スライド説明資料（HTML/CSS/JS）を生成し、音声付き動画として出力する
---

# プレゼンテーション用アニメーションWebページ生成 → 動画化スキル

あなたは与えられた台本やテーマをもとに、**解説動画のコンテンツ部分として使用できる、高品質なアニメーションWebページ（HTML/CSS/JS）をフルスクラッチで生成**し、**音声付きの動画ファイル（mp4）として出力**するまでを一貫して行います。

---

## 🎯 プロジェクトの最終目的

- この成果物は、**YouTube等の「キャラクター同士の対話型解説動画（例: ずんだもん解説など）」で、キャラクターの横や背景に表示されるメインコンテンツ**として録画・使用されます。
- 概念の「説明」は、台本を読み上げるキャラクターの音声が担います。スライドの役割は「説明する」ことではなく、**視聴者の理解を視覚的に助け、映像として見続けたいと思わせること**です。

---

## 📝 利用方法（インプット例）

```
【テーマ名】llm_text_generation

【台本】
（ここに解説動画の台本テキストを貼り付け）
```

台本の形式（会話形式・箇条書きなど）は問いません。

---

## 🔁 全体ワークフロー（概要）

以下の Phase 1〜3 を **この順序で** 実行してください。

| Phase | 内容 | 成果物 |
|-------|------|--------|
| **Phase 1** | Webプレゼンテーション生成 | `index.html`, `style.css`, `script.js` |
| **Phase 2** | 音声生成 | `scene_map.json`, `audio/*.wav`, `scene_durations.json` |
| **Phase 3** | 録画 + 音声合成 | `recording.mp4`, `final_output.mp4` |

---

# Phase 1：Webプレゼンテーション生成

## 🎞️ シーン分割の粒度

- **会話の展開や説明のフェーズが変わるごとに**こまめにシーン（スライド）を切り替えてください。
- （例：1つのトピックの中でも、「問題提起」「図解ステップ1」「図解ステップ2」「結論」など）
- 台本全体をただ数個の「大見出し」レベルでまとめた数シーンだけにしないでください。
- **オープニング・まとめ等の「会話のみのセクション」を省略しないこと。** 技術説明ブロックだけでなく、動画冒頭の前座的な会話や締めの会話にも必ずシーンを作成してください。会話のみのシーンでは、キーワードや名言を大きく表示しつつ、背景アニメーションで画面を彩ってください。

## 🎨 デザインと演出のルール

### シーン制御
- 縦スクロールではなく、1画面を占有するスライド形式で構築してください。
- シーンの進行・戻る操作は**キー操作（矢印キー等）のみ**とし、画面上にはボタンや操作ヒントのUIを一切配置しないでください（録画時の不要な映り込みを避けるため）。
- **必ず `window.goTo(index)` という固定名のグローバル関数**を実装・公開してください（録画スクリプトがこの名前で呼び出します）。

### テキストは「ラベル・キーワード」のみ
- スライドに「説明文」を書かないでください。**概念の説明は音声ナレーションが行います。**
- スライドに載せるテキストは、**シーンのタイトル・キーワード・短いラベル**に限定してください。
- 文字は大きく、少なく。遠くから見ても一瞬で読めるサイズにしてください。
- 絵文字は使用しないでください。

### アニメーションで「説明する」
- テキストの代わりに、**アニメーション自体が概念を説明するように設計**してください。
- 例：トークン化なら文字列が分割されるアニメーション、Attentionなら単語間に光の線が伸びるアニメーション。
- 「図解＋動き」で直感的に理解できるシーンを目指してください。

### テーマとトーン
- デフォルトは**クリーンで洗練されたホワイトテーマ（明るい背景）**。
- モダンでリッチなデザイン（美しいグラデーション、滑らかなシャドウなど）を取り入れること。

## 🎬 レイアウト方針

### 「パワーポイント」のように情報を整理する

このスライドは「映像作品」ではなく、**パワポのように情報が整理・構造化されたスライド資料**です。ただし、通常のパワポと違うのは、**図解やダイアグラムがアニメーションで動く**という点です。

#### レイアウトの設計原則
- **明確な見出しとセクション区切り** 
- **カード・ボックスで情報をグルーピング**
- **色分けでカテゴリを表現**（例：トークン化＝青系、Attention＝紫系）
- **矢印・コネクタでフローを明示**
- **余白を十分に取る**

#### アニメーションの役割
アニメーションは装飾ではなく、**概念の理解を助けるため**に使ってください。会話のみのシーンでは、キーワードを大きく表示し、背景に控えめなアンビエントアニメーションを入れること。

## ⏱️ アニメーションの設計

- 図解が少ないシーンでも、背景でゆっくりと動く要素を必ず組み込み、画面が完全に静止しないようにしてください。

## ⚠️ CSS設計の注意点（Headless録画対策）

以下はPuppeteer headlessモードでの録画時の問題を防止するルールです：

1. **opacity: 0 → visibleパターンの注意**: あるシーンで `opacity: 0` → `.visible` クラスで表示するパターンを使った場合、**別シーンで同じCSS classのHTML要素を再利用しているときは、必ずCSSオーバーライドで表示状態にすること**。
   ```css
   /* 例: Scene 7のtoken-blockはopacity: 0 + .visible で制御するが、
      Scene 8のtoken-id-card内でも再利用されている場合 */
   .token-id-card .token-block {
       opacity: 1;
       transform: translateY(0) scale(1);
   }
   ```

2. **全CSSクラスが定義されていること**: HTMLで参照しているCSSクラス（`.label--amber`, `.title-huge` 等）が必ず `style.css` に定義されていること。

## 💻 出力先とディレクトリ構成

```
presentation/
└── {テーマ名}/        ← テーマ名は英語スネークケース
     ├── index.html
     ├── style.css
     └── script.js
```

- ファイルは必ず上記3ファイルに分割してください。

## ⛔ 禁止事項

- **ファイルを生成した後にブラウザで開いて確認する行為は行わないでください。** 確認はユーザー自身が行います。

## 生成手順

台本が長い場合、**1回のプロンプトで全体を一気に生成しようとしないでください**。

### Step 1：設計を提示する

台本全体を読んだうえで、以下を決定しユーザーに提示してください。

1. **ブロック分割案**：台本をどのようなブロックに分けるか
2. **各ブロックのシーン構成案**：各ブロックで何シーン作るか、各シーンの概要
3. **デザインテーマ案**：全体を通じて使うカラーパレット・トーン・フォント

> ⚠️ **オープニング・まとめ等の「会話のみのセクション」を省略しないこと。**

設計をユーザーに確認してから、次のステップへ進むこと。

### Step 2：1ブロックずつ生成する

設計が確定したら、**1ブロックずつ順番にコードを生成**してください。

- 1ブロックあたり2～6シーン程度を目安。
- 各ブロックは、**シーンのHTML断片とそれに対応するCSS・JSの追加分**として出力。
- 1ブロック生成が終わったら、ユーザーの確認・修正を受けてから次のブロックへ。

### Step 3：全ブロック完成後、統合する

3ファイル（`index.html` / `style.css` / `script.js`）に統合し、以下を確認：

- 全シーンを通じてデザインの一貫性があるか
- `window.goTo(index)` がすべてのシーンに正しく対応しているか
- アニメーションが競合したり止まったりしていないか
- 上記「CSS設計の注意点」に違反していないか

---

# Phase 2：音声生成（VOICEVOX）

## 前提条件
- VOICEVOX がローカルで起動していること（デフォルト: `http://localhost:50021`）
- `ffmpeg` がPATHに通っていること
- `puppeteer` がインストール済みであること（プロジェクトルートの `node_modules`）

## Step 4：`scene_map.json` を作成する

台本のセリフをシーンに対応付けた `scene_map.json` を作成する。**これは Phase 2〜3 の全工程の入力データ**であり、正確に作成する必要がある。

### ⚠️ 最重要ルール：HTMLシーンとの1:1対応

scene_map.json の各エントリは、HTML内の `.scene` 要素と **完全に1:1で対応** しなければならない。

- `scene_map.json` の `id: N` は、HTML内で **N番目（0-indexed）** に出現する `.scene` 要素に対応する
- **scene_map のエントリ数 = HTML の `.scene` 要素の数** でなければならない
- 台本の `<!-- SCENE: ... -->` マーカーの下にあるセリフは、**対応するHTMLシーンと同じIDの scene_map エントリの `lines` に入れる**

**❌ よくある間違い（絶対にやってはいけない）:**

```
❌ 間違い: HTMLにタイトルシーンがある場合に、scene_mapでhold_sec付きの
   無音シーンを「追加」し、台本セリフをScene 1以降に入れる
   → セリフと映像が全体的に1シーンずつズレる
```

**✅ 正しいやり方:**

```
✅ 台本の <!-- SCENE: タイトルカード --> の下にセリフがあるなら、
   そのセリフはScene 0のlinesに入れる（HTMLのScene 0 = タイトルビジュアル）
   → 「タイトルが表示されながら最初のセリフが読まれる」のが正しい動作
```

> `hold_sec` を使うのは、HTMLに **セリフがないシーン**（エンディング画面など）が存在する場合のみ。台本にセリフがあるシーンには `hold_sec` を使わないこと。

### scene_map.json のフォーマット

```json
{
  "voicevox_url": "http://localhost:50021",
  "speakers": {
    "ずんだもん": 3,
    "めたん": 2
  },
  "speed_scale": 1.15,
  "inter_line_silence": 0.3,
  "scene_end_padding": 0.5,
  "scenes": [
    {
      "id": 0, "title": "タイトル", "hold_sec": 0,
      "lines": [
        { "speaker": "めたん", "text": "最初のセリフ..." },
        { "speaker": "ずんだもん", "text": "次のセリフ..." }
      ]
    },
    {
      "id": 1, "title": "衝撃の事実", "hold_sec": 0,
      "lines": [
        { "speaker": "めたん", "text": "セリフ内容..." },
        { "speaker": "ずんだもん", "text": "セリフ内容..." }
      ]
    }
  ]
}
```

### 作成ルール

| フィールド | 説明 |
|-----------|------|
| `id` | シーンのインデックス（0-indexed、HTML内の `.scene` の出現順） |
| `title` | シーンの**コンテンツタイトル**（チャプター表示・ログ表示用）。下記「titleの決め方」を参照 |
| `hold_sec` | **セリフがない**シーンの表示固定時間（秒）。セリフありのシーンは必ず `0`。台本にセリフがあるのに `hold_sec` を設定してはならない |
| `lines` | そのシーンで読み上げるセリフの配列（順序 = 読み上げ順） |
| `lines[].speaker` | `speakers` で定義した話者名 |
| `lines[].text` | 読み上げテキスト。括弧「」や記号を過度に含めない |
| `speed_scale` | 読み上げ速度（1.0 = 等速、1.15 = 普通の動画向け推奨値） |
| `inter_line_silence` | セリフ間の無音秒数（0.3推奨） |
| `scene_end_padding` | シーン末尾パディング秒数（0.5推奨） |

### ⚠️ `title` の決め方（重要）

台本のSCENEマーカーは以下の形式になっている：

```
<!-- SCENE: ビジュアルパターン「コンテンツタイトル」 -->
```

`title` フィールドには、**「コンテンツタイトル」の部分（括弧内の文字列）**を使うこと。**ビジュアルパターン名（タイトルカード・段階的リスト・数値インパクト等）は `title` に入れてはならない。** ビジュアルパターンはHTML/CSSのレイアウト種類を指定するものであり、シーンの内容を表すものではない。

**❌ よくある間違い:**

```
台本: <!-- SCENE: タイトルカード「マシュマロ実験の真実」 -->
❌ "title": "タイトルカード"   ← ビジュアルパターン名を入れてしまっている
```

**✅ 正しい例:**

```
台本: <!-- SCENE: タイトルカード「マシュマロ実験の真実」 -->
✅ "title": "マシュマロ実験の真実"   ← コンテンツタイトルを入れる

台本: <!-- SCENE: 数値インパクト「SAT 210点の差」 -->
✅ "title": "SAT 210点の差"

台本: <!-- SCENE: 比較対照「通説 vs 実際の研究」 -->
✅ "title": "通説 vs 実際の研究"
```

この `title` はRemotionのサイドバーのチャプター名や字幕データの `sceneTitle` として最終出力まで伝播するため、正確に設定すること。

### 作成後の検証手順（必須）

scene_map.json を作成したら、以下を **必ず** 確認すること：

1. **エントリ数の一致**: `scene_map.json` のシーン数と、HTMLの `.scene` 要素の数が一致するか
2. **先頭シーンの確認**: Scene 0 の `lines` に台本の最初のセリフが入っているか（無音の `hold_sec` だけになっていないか）
3. **末尾シーンの確認**: 最後のシーンのセリフがHTMLの最後のシーンのビジュアルと意味的に対応しているか
4. **IDの連続性**: `id` が 0 から連番で抜けがないか

### テキスト前処理のポイント

台本からセリフを抽出する際、以下の変換を行うこと：

1. **記号の読み替え**: `(x, y, z)` → `エックス、ワイ、ゼット` のように、VOICEVOXが正しく発音できる表記にする
2. **括弧の除去**: かぎ括弧「」は発音されないので、使わないか最小限にする
3. **英語の読み替え**: `BPE` → `ビーピーイー`、`Word Embedding` → `ワードエンベディング` のように
4. **セリフの分割**: あまりに長い1セリフは自然な切れ目で2つに分割する
5. **話者の指定**: `speakers` のキー名と `lines[].speaker` が完全一致すること

## Step 5：音声を生成する

// turbo

```bash
node presentation/tools/generate_audio.js {テーマ名}
```

**このコマンドが行うこと:**
1. `scene_map.json` を読み込む
2. 各セリフをVOICEVOX APIで音声合成 → `audio/scene_XX_YY.wav` として保存
3. 各シーンの合計表示秒数を計算 → `scene_durations.json` を自動生成

**注意:** 
- 既存の `.wav` ファイルはスキップされる（再生成したい場合は `audio/` ディレクトリを削除する）
- コマンドが完了したら `scene_durations.json` が生成されたことを確認する

---

# Phase 3：録画 + 音声合成

## Step 6：並列録画を実行する

// turbo

```bash
node presentation/tools/record.js {テーマ名} 4 1920x1080
```

**引数:**
- `{テーマ名}`: プロジェクトディレクトリ名
- `4`: 並列ワーカー数（CPUコア数に合わせて調整）
- `1920x1080`: 録画解像度
- *(省略可)* 4番目の引数: CSS zoom倍率（デフォルト: `1.5`）

> **CSS zoom について:** プレゼンテーションのコンテンツは `max-width` と余白付きで中央配置されているため、1920x1080をそのまま録画するとコンテンツが小さく見える。CSS zoom を適用することで、アスペクト比を維持したまま映像内のコンテンツを拡大し、余白を減らせる。デフォルト値 `1.5` は Remotion の MathLayout に埋め込んだ際に最適なバランスになるよう調整されている。

**このコマンドが行うこと:**
1. `scene_durations.json` を読み込む
2. シーンをワーカー数で分割し、並列で Puppeteer スクリーンキャスト録画
3. 各チャンクを `chunks/chunk_XX.mkv` に保存
4. ffmpeg で全チャンクを結合 → `recording.mp4` を出力

**並列録画の技術的注意点:**
- 各チャンクの先頭でシーンの初期化のため、対象シーンに1.5秒滞在 → 前シーンに1.5秒滞在 という事前ウォームアップを行う
- チャンクからmp4への結合時は `libx264` で再エンコードする（mkv→mp4変換）
- ffmpegの完了待ちタイムアウトは120秒。killせず自然終了を待つ
- `browser.close()` は5秒タイムアウト付き。ハングした場合はプロセスを強制kill

**完了確認:**
- `recording.mp4` が生成されたことを確認
- **映像の長さが `scene_durations.json` の合計秒数にほぼ一致すること**を以下で確認する：

```bash
ffprobe -v error -show_entries format=duration -of csv=p=0 "presentation/{テーマ名}/recording.mp4"
```

映像が大幅に短い場合（例: 期待17分なのに9分しかない）、チャンクファイルの破損を疑う。`chunks/` 内の各 `.mkv` ファイルを個別に `ffprobe` で確認し、壊れたチャンクがあれば削除して `record.js` を再実行する。

## Step 7：音声+映像を合成する

// turbo

```bash
node presentation/tools/merge_audio.js {テーマ名}
```

**このコマンドが行うこと:**
1. `scene_durations.json` と `audio/scene_XX_YY.wav` を読み込む
2. 各シーンのセリフ音声をセリフ間の無音で繋いで1シーン分の音声にする
3. 音声が場面の尺より短い場合は無音でパディング、長い場合はトリムする
4. 全シーンの音声を結合 → `audio/full_audio.wav`
5. `recording.mp4` と `full_audio.wav` を合成 → `final_output.mp4` を出力

## Step 8：最終確認

`final_output.mp4` をユーザーに案内する。

---

## 📂 最終ディレクトリ構成

```
presentation/
├── tools/
│   ├── generate_audio.js   # 音声生成スクリプト
│   ├── record.js           # 画面録画スクリプト（並列対応）
│   └── merge_audio.js      # 音声+映像合成スクリプト
└── {テーマ名}/
    ├── index.html           # プレゼンテーション本体
    ├── style.css            # スタイルシート
    ├── script.js            # アニメーション・制御JS
    ├── scene_map.json       # 台本→シーン対応マップ（自分で作成）
    ├── scene_durations.json # シーン表示秒数（generate_audio.jsが自動生成）
    ├── audio/               # 生成された音声ファイル群
    │   ├── scene_00_00.wav  # Scene0, Line0
    │   ├── scene_01_00.wav  # Scene1, Line0
    │   └── full_audio.wav   # 全体結合音声
    ├── chunks/              # 録画チャンク（一時ファイル）
    │   ├── chunk_00.mkv
    │   └── chunk_01.mkv
    ├── recording.mp4        # 無音映像
    └── final_output.mp4     # ★最終出力（映像+音声）
```

---

## 🐛 既知の問題と対処法

| 問題 | 原因 | 対処法 |
|------|------|--------|
| 特定シーンの要素が録画で非表示 | CSSの `opacity: 0` が別シーンでオーバーライドされていない | 該当要素のCSSに `.parent .child { opacity: 1; }` を追加 |
| 録画映像が期待より短い | チャンクファイルのffmpegが正常終了していない | 各チャンクを `ffprobe` で確認し、壊れたチャンクを削除して再録画 |
| `browser.close()` でハング | Puppeteer headlessのバグ | record.js は5秒タイムアウト+強制kill済み。通常は自動回復 |
| `moov atom not found` エラー | mp4形式でffmpegをkillした | チャンクはmkv形式で出力済み。通常は発生しない |
| 音声の長さとシーンがずれる | `scene_map.json` のシーンIDが HTML のシーン順と不一致 | IDが0-indexedでHTML内の `.scene` の出現順と一致しているか確認 |
